From decea22672408d50672480740da50536cdda5ac8 Mon Sep 17 00:00:00 2001
From: Nirbheek Chauhan <nirbheek@centricular.com>
Date: Fri, 29 Jun 2018 17:12:49 +0530
Subject: [PATCH 1/3] Allow command lists for find_program cross file overrides

This is accepted by all other binaries in the cross file. With this
change, we also don't check whether the specified command exists at
configure time, but that's probably a feature anyway.

Fixes https://github.com/mesonbuild/meson/issues/3737
---
 mesonbuild/interpreter.py                 | 8 ++++++--
 run_unittests.py                          | 5 +++--
 test cases/unit/12 cross prog/meson.build | 4 ++++
 3 files changed, 13 insertions(+), 4 deletions(-)

diff --git a/mesonbuild/interpreter.py b/mesonbuild/interpreter.py
index d008eb97..82e7d21b 100644
--- a/mesonbuild/interpreter.py
+++ b/mesonbuild/interpreter.py
@@ -2627,8 +2627,12 @@ external dependencies (including libraries) must go to "dependencies".''')
             if not isinstance(p, str):
                 raise InterpreterException('Executable name must be a string.')
             if p in bins:
-                exename = bins[p]
-                extprog = dependencies.ExternalProgram(exename, silent=silent)
+                command = bins[p]
+                if isinstance(command, (list, str)):
+                    extprog = dependencies.ExternalProgram(p, command=command, silent=silent)
+                else:
+                    raise InterpreterException('Invalid type {!r} for binary {!r} in cross file'
+                                               ''.format(command, p))
                 progobj = ExternalProgramHolder(extprog)
                 return progobj
 
diff --git a/run_unittests.py b/run_unittests.py
index 0abe419e..8b664a30 100755
--- a/run_unittests.py
+++ b/run_unittests.py
@@ -3207,7 +3207,8 @@ class LinuxlikeTests(BasePlatformTests):
 c = '/usr/bin/cc'
 ar = '/usr/bin/ar'
 strip = '/usr/bin/ar'
-sometool.py = '%s'
+sometool.py = ['{0}']
+someothertool.py = '{0}'
 
 [properties]
 
@@ -3216,7 +3217,7 @@ system = 'linux'
 cpu_family = 'arm'
 cpu = 'armv7' # Not sure if correct.
 endian = 'little'
-''' % os.path.join(testdir, 'some_cross_tool.py'))
+'''.format(os.path.join(testdir, 'some_cross_tool.py')))
         crossfile.flush()
         self.meson_cross_file = crossfile.name
         self.init(testdir)
diff --git a/test cases/unit/12 cross prog/meson.build b/test cases/unit/12 cross prog/meson.build
index e6287013..a7adeb28 100644
--- a/test cases/unit/12 cross prog/meson.build	
+++ b/test cases/unit/12 cross prog/meson.build	
@@ -2,11 +2,15 @@ project('cross find program', 'c')
 
 native_exe = find_program('sometool.py', native : true)
 cross_exe = find_program('sometool.py')
+cross_other_exe = find_program('someothertool.py')
 
 native_out = run_command(native_exe).stdout().strip()
 cross_out = run_command(cross_exe).stdout().strip()
+cross_other_out = run_command(cross_other_exe).stdout().strip()
 
 assert(native_out == 'native',
   'Native output incorrect:' + native_out)
 assert(cross_out == 'cross',
   'Cross output incorrect:' + cross_out)
+assert(cross_out == cross_other_out,
+  'Cross output incorrect:' + cross_other_out)
-- 
2.17.1


From 30bf5c818ed28e243f34493413d01cdefa67548e Mon Sep 17 00:00:00 2001
From: Nirbheek Chauhan <nirbheek@centricular.com>
Date: Fri, 29 Jun 2018 19:33:17 +0530
Subject: [PATCH 2/3] Add a helper for fetching of binaries from cross files

A number of cases have to be taken care of while doing this, so
refactor it into a helper on ExternalProgram and use it everywhere.

1. Command is a list of len > 1, use it as-is
2. Command is a list of len == 1 (or a string), use as a string
3. If command is an absolute path, use it as-is
4. If command is not an absolute path, search for it
---
 mesonbuild/dependencies/base.py | 21 +++++++++++++++++++--
 mesonbuild/dependencies/ui.py   |  6 +++---
 mesonbuild/interpreter.py       | 18 +++++++-----------
 mesonbuild/modules/windows.py   | 18 ++++++++++--------
 4 files changed, 39 insertions(+), 24 deletions(-)

diff --git a/mesonbuild/dependencies/base.py b/mesonbuild/dependencies/base.py
index 3bff0d23..b556574c 100644
--- a/mesonbuild/dependencies/base.py
+++ b/mesonbuild/dependencies/base.py
@@ -438,8 +438,7 @@ class PkgConfigDependency(ExternalDependency):
                 if self.required:
                     raise DependencyException('Pkg-config binary missing from cross file')
             else:
-                pkgname = environment.cross_info.config['binaries']['pkgconfig']
-                potential_pkgbin = ExternalProgram(pkgname, silent=True)
+                potential_pkgbin = ExternalProgram.from_cross_info(environment.cross_info, 'pkgconfig')
                 if potential_pkgbin.found():
                     self.pkgbin = potential_pkgbin
                     PkgConfigDependency.class_pkgbin = self.pkgbin
@@ -789,6 +788,24 @@ class ExternalProgram:
         r = '<{} {!r} -> {!r}>'
         return r.format(self.__class__.__name__, self.name, self.command)
 
+    @staticmethod
+    def from_cross_info(cross_info, name):
+        if name not in cross_info.config['binaries']:
+            return NonExistingExternalProgram()
+        command = cross_info.config['binaries'][name]
+        if not isinstance(command, (list, str)):
+            raise MesonException('Invalid type {!r} for binary {!r} in cross file'
+                                 ''.format(command, name))
+        if isinstance(command, list):
+            if len(command) == 1:
+                command = command[0]
+        # We cannot do any searching if the command is a list, and we don't
+        # need to search if the path is an absolute path.
+        if isinstance(command, list) or os.path.isabs(command):
+            return ExternalProgram(name, command=command, silent=True)
+        # Search for the command using the specified string!
+        return ExternalProgram(command, silent=True)
+
     @staticmethod
     def _shebang_to_cmd(script):
         """
diff --git a/mesonbuild/dependencies/ui.py b/mesonbuild/dependencies/ui.py
index 72958ddc..324f9fa9 100644
--- a/mesonbuild/dependencies/ui.py
+++ b/mesonbuild/dependencies/ui.py
@@ -291,10 +291,10 @@ class QtBaseDependency(ExternalDependency):
                 self.bindir = os.path.join(prefix, 'bin')
 
     def _find_qmake(self, qmake):
-        # Even when cross-compiling, if we don't get a cross-info qmake, we
+        # Even when cross-compiling, if a cross-info qmake is not specified, we
         # fallback to using the qmake in PATH because that's what we used to do
-        if self.env.is_cross_build():
-            qmake = self.env.cross_info.config['binaries'].get('qmake', qmake)
+        if self.env.is_cross_build() and 'qmake' in self.env.cross_info.config['binaries']:
+            return ExternalProgram.from_cross_info(self.env.cross_info, 'qmake')
         return ExternalProgram(qmake, silent=True)
 
     def _qmake_detect(self, mods, kwargs):
diff --git a/mesonbuild/interpreter.py b/mesonbuild/interpreter.py
index 82e7d21b..ec041427 100644
--- a/mesonbuild/interpreter.py
+++ b/mesonbuild/interpreter.py
@@ -2618,23 +2618,19 @@
             self.coredata.base_options[optname] = oobj
 
     def program_from_cross_file(self, prognames, silent=False):
-        bins = self.environment.cross_info.config['binaries']
+        cross_info = self.environment.cross_info
+        prog = dependencies.NonExistingExternalProgram()
         for p in prognames:
             if hasattr(p, 'held_object'):
                 p = p.held_object
             if isinstance(p, mesonlib.File):
                 continue # Always points to a local (i.e. self generated) file.
             if not isinstance(p, str):
-                raise InterpreterException('Executable name must be a string.')
-            if p in bins:
-                command = bins[p]
-                if isinstance(command, (list, str)):
-                    extprog = dependencies.ExternalProgram(p, command=command, silent=silent)
-                else:
-                    raise InterpreterException('Invalid type {!r} for binary {!r} in cross file'
-                                               ''.format(command, p))
-                progobj = ExternalProgramHolder(extprog)
-                return progobj
+                raise InterpreterException('Executable name must be a string')
+            prog = ExternalProgram.from_cross_info(cross_info, p)
+            if prog.found():
+                break
+        return ExternalProgramHolder(prog)
 
     def program_from_system(self, args, silent=False):
         # Search for scripts relative to current subdir.
diff --git a/mesonbuild/modules/windows.py b/mesonbuild/modules/windows.py
index 44a9ebb1..fbe01518 100644
--- a/mesonbuild/modules/windows.py
+++ b/mesonbuild/modules/windows.py
@@ -14,12 +14,13 @@
 import os
 
 from .. import mlog
-from .. import mesonlib, dependencies, build
+from .. import mesonlib, build
 from ..mesonlib import MesonException, extract_as_list
 from . import get_include_args
 from . import ModuleReturnValue
 from . import ExtensionModule
 from ..interpreterbase import permittedKwargs
+from ..dependencies import ExternalProgram
 
 class WindowsModule(ExtensionModule):
 
@@ -49,7 +50,7 @@ class WindowsModule(ExtensionModule):
         extra_args += get_include_args(inc_dirs)
 
         if comp.id == 'msvc':
-            rescomp = dependencies.ExternalProgram('rc', silent=True)
+            rescomp = ExternalProgram('rc', silent=True)
             res_args = extra_args + ['/nologo', '/fo@OUTPUT@', '@INPUT@']
             suffix = 'res'
         else:
@@ -58,22 +59,23 @@ class WindowsModule(ExtensionModule):
             for arg in extra_args:
                 if ' ' in arg:
                     mlog.warning(m.format(arg))
-            rescomp_name = None
+            rescomp = None
             # FIXME: Does not handle `native: true` executables, see
             # https://github.com/mesonbuild/meson/issues/1531
             if state.environment.is_cross_build():
                 # If cross compiling see if windres has been specified in the
                 # cross file before trying to find it another way.
-                rescomp_name = state.environment.cross_info.config['binaries'].get('windres')
-            if rescomp_name is None:
+                cross_info = state.environment.cross_info
+                rescomp = ExternalProgram.from_cross_info(cross_info, 'windres')
+            if not rescomp or not rescomp.found():
                 # Pick-up env var WINDRES if set. This is often used for
                 # specifying an arch-specific windres.
-                rescomp_name = os.environ.get('WINDRES', 'windres')
-            rescomp = dependencies.ExternalProgram(rescomp_name, silent=True)
+                rescomp = ExternalProgram(os.environ.get('WINDRES', 'windres'), silent=True)
             res_args = extra_args + ['@INPUT@', '@OUTPUT@']
             suffix = 'o'
         if not rescomp.found():
-            raise MesonException('Could not find Windows resource compiler %s.' % ' '.join(rescomp.get_command()))
+            raise MesonException('Could not find Windows resource compiler {!r}'
+                                 ''.format(rescomp.get_path()))
 
         res_targets = []
 
-- 
2.17.1


From f8cac71bbf7455866c37d6576da447f9016ff283 Mon Sep 17 00:00:00 2001
From: Nirbheek Chauhan <nirbheek@centricular.com>
Date: Sat, 30 Jun 2018 17:26:46 +0530
Subject: [PATCH 3/3] custom targets: Only add a dependency on absolute path
 external programs

If the external program is a string that is meant to be searched in
PATH, we can't add a dependency on it at configure time because we don't
know where it will be at compile time.
---
 mesonbuild/build.py | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/mesonbuild/build.py b/mesonbuild/build.py
index 6e540a8b..ec0d8ccc 100644
--- a/mesonbuild/build.py
+++ b/mesonbuild/build.py
@@ -1713,7 +1713,11 @@ class CustomTarget(Target):
                 if not c.found():
                     m = 'Tried to use not-found external program {!r} in "command"'
                     raise InvalidArguments(m.format(c.name))
-                self.depend_files.append(File.from_absolute_file(c.get_path()))
+                path = c.get_path()
+                if os.path.isabs(path):
+                    # Can only add a dependency on an external program which we
+                    # know the absolute path of
+                    self.depend_files.append(File.from_absolute_file(path))
                 final_cmd += c.get_command()
             elif isinstance(c, (BuildTarget, CustomTarget)):
                 self.dependencies.append(c)
-- 
2.17.1

